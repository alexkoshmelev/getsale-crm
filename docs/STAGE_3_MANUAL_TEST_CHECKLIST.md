# ЭТАП 3 — Чек-лист ручного тестирования (стабилизация)

После реализации ЭТАПА 3 (Lead → Deal) перед переходом к ЭТАПУ 4 и ЭТАПУ 2 рекомендуется **реально** пройти сценарии ниже — не формально («вроде работает»), а с проверкой событий, БД и multi-tenant. Цель — убедиться, что конверсия считается правильно, события публикуются, дубли и побочные эффекты отсутствуют.

---

## Предусловия

- Миграции применены: `deals.lead_id` + partial unique index, этап Converted добавлен во все нужные пайплайны.
- Сервисы подняты (CRM, Pipeline, RabbitMQ при необходимости проверки событий).
- Есть тестовый tenant (organization), пользователь, контакт, пайплайн с этапом Converted.

---

## Сценарий A — Успешная конверсия (лид → сделка)

**Цель:** создание сделки с привязкой к лиду переводит лида в Converted и оставляет консистентные данные и события.

**Шаги:**

1. Создать лид (контакт + пайплайн + стадия не Converted), запомнить `leadId`, `pipelineId`, `contactId`, `stageId` лида.
2. Вызвать `POST /api/crm/deals` с телом, например:
   - `pipelineId` = из лида (или не передавать, если API берёт из лида),
   - `contactId` = из лида (или не передавать),
   - `leadId` = полученный `leadId`,
   - при необходимости остальные поля (company_id, value и т.д. по контракту).

**Проверить:**

- [ ] Ответ 201, в теле сделки есть `leadId`, равный переданному.
- [ ] `GET /api/crm/leads/:leadId` (или эквивалент): у лида `stage` = Converted (или stage_id указывает на этап Converted).
- [ ] **В БД вручную:** в `stage_history` есть запись для этого лида (переход в Converted; в текущей схеме — client_id = contact_id, deal_id = NULL; после ЭТАПА 2 — entity_type = 'lead', entity_id = leadId).
- [ ] **События в RabbitMQ:** в очереди/обмене появились `deal.created` (в data есть `leadId`) и `lead.converted` (leadId, dealId, pipelineId, convertedAt). Проверить payload, не только факт публикации.

---

## Сценарий B — Защита от второй сделки по одному лиду (409)

**Цель:** один лид не может быть привязан к двум сделкам.

**Шаги:**

1. Взять лид, по которому уже создана сделка (например, из сценария A).
2. Вызвать `POST /api/crm/deals` с тем же `leadId` и корректными pipelineId/contactId.

**Проверить:**

- [ ] Ответ **409** (Conflict).
- [ ] В БД по этому лиду по-прежнему одна сделка с `lead_id = leadId`.

---

## Сценарий C — Запрет смены стадии лида из Converted (400)

**Цель:** лид в финальной стадии Converted нельзя перевести обратно.

**Шаги:**

1. Взять лид в стадии Converted (после сценария A или создав сделку с leadId).
2. Вызвать смену стадии лида (например, `PATCH /api/pipeline/leads/:id/stage` или аналог с `stageId` другой стадии).

**Проверить:**

- [ ] Ответ **400** (Bad Request) с понятным сообщением.
- [ ] Стадия лида в БД осталась Converted.

---

## Сценарий D — Сделка без leadId (поведение как раньше)

**Цель:** создание сделки без привязки к лиду не меняет лидов и не требует leadId.

**Шаги:**

1. Вызвать `POST /api/crm/deals` **без** поля `leadId` (pipelineId и при необходимости contactId/company_id передать как обычно).

**Проверить:**

- [ ] Ответ 201, сделка создана.
- [ ] В теле сделки `leadId` отсутствует или null.
- [ ] Никакие лиды не переведены в Converted.
- [ ] Событие `deal.created` опубликовано без `leadId` (или с null); `lead.converted` не публикуется.

---

## Сценарий E — Multi-tenant (обязательно)

**Цель:** нельзя создать сделку с `leadId`, принадлежащим другой организации. Это самый опасный момент для утечки данных.

**Шаги:**

1. Иметь две организации (Org A и Org B), в Org B — лид с `leadId`.
2. От имени пользователя **Org A** вызвать `POST /api/crm/deals` с телом, где `leadId` = лид из Org B (и валидные для Org A pipelineId/contactId по контракту, если требуются).

**Проверить:**

- [ ] Ответ **403 Forbidden** или **404 Not Found** (лид не найден в контексте организации). Ни в коем случае не 201.
- [ ] В БД Org A: сделка с этим lead_id не создана. В БД Org B: лид не переведён в Converted.

---

## Сценарий F — Rollback при ошибке

**Цель:** при сбое внутри транзакции (до COMMIT) данные не остаются в половинчатом состоянии.

**Шаги (по возможности):**

1. Симулировать сбой после обновления лида, но до COMMIT (например, временно бросить ошибку в коде после `UPDATE leads SET stage_id = ...` или отключить БД на момент запроса), либо проверить сценарий 409: при попытке второй сделки по тому же лиду транзакция откатывается и дубликат не создаётся.
2. Убедиться, что после успешного создания сделки с leadId при последующем сбое публикации событий (например, RabbitMQ недоступен) данные в БД уже зафиксированы — отката нет (события публикуются после COMMIT). Документировать поведение: «at-least-once» события при сбое брокера.

**Проверить:**

- [ ] При откате транзакции: лид не переведён в Converted, сделка не создана, в stage_history нет лишней записи.
- [ ] Понимание: если COMMIT прошёл, а публикация событий упала — данные консистентны; события можно переопубликовать или обработать иначе.

---

## Сценарий G — Race condition (критично)

**Цель:** при одновременных запросах создания сделки с одним и тем же leadId создаётся ровно одна сделка, нет partial state и лишних событий. Это самое уязвимое место до ЭТАПОВ 2 и 4; если race-баг есть сейчас — позже его будет почти невозможно отловить.

**Шаги:**

1. Создать один лид (не в Converted), запомнить `leadId`, `pipelineId`, `contactId` и прочие поля для тела запроса.
2. **Одновременно** отправить 10 запросов `POST /api/crm/deals` с одинаковым телом (включая один и тот же `leadId`). Использовать параллельные запросы (скрипт, Postman/Insomnia с concurrent run, или нагрузочный инструмент).

**Проверить:**

- [ ] В БД **ровно 1** запись в `deals` с `lead_id = leadId`.
- [ ] У этого лида в БД **ровно 1** запись в `stage_history` с переходом в Converted (и лид в стадии Converted).
- [ ] Опубликовано **ровно 1** событие `lead.converted` (и ровно один `deal.created` с этим leadId).
- [ ] Остальные запросы получили **409** Conflict (или один 201, остальные 409). Никаких 500 и половинчатых состояний.

Если сценарий G проходит — архитектура реально устойчива к гонкам перед ЭТАПОМ 2 и ЭТАПОМ 4.

---

## Conversion endpoint

После добавления `GET /api/crm/analytics/conversion`:

- [ ] Вызвать `GET /api/crm/analytics/conversion` (без параметров) — в ответе `totalLeads`, `convertedLeads`, `conversionRate`.
- [ ] Вызвать `GET /api/crm/analytics/conversion?pipelineId=<id>` — метрики в рамках одного пайплайна.
- [ ] Убедиться, что conversionRate = convertedLeads / totalLeads (при totalLeads > 0); при 0 лидах — 0.

Это закрепляет модель 1 Lead → 1 Deal и даёт baseline метрику до изменений ЭТАПА 2.

---

## Автоматизированный прогон

Скрипт `scripts/stage3-e2e-test.mjs` проверяет сценарии A–D, G и conversion endpoint (сценарии F и проверка RabbitMQ/БД — вручную).

**Предусловия:** CRM (3002), Pipeline (3008), Postgres подняты; миграции и seed применены.

```bash
# Получить тестовые user/org ID (после migrate + seed)
npm run stage3-ids

# Экспортировать переменные (пример вывода из stage3-ids)
export TEST_USER_ID=<uuid> TEST_ORGANIZATION_ID=<uuid>
# Для сценария E (multi-tenant): TEST_ORG_B_USER_ID, TEST_ORG_B_ORGANIZATION_ID

# Запуск тестов (обращения к CRM и Pipeline напрямую, без API Gateway)
npm run stage3-e2e
```

Переменные окружения: `CRM_URL`, `PIPELINE_URL` (по умолчанию localhost:3002, 3008).

---

## Итог и порядок действий

1. **Пройти чек-лист по-настоящему:** сценарии A–G, проверка RabbitMQ, проверка БД, multi-tenant, conversion endpoint.
2. **Прогнать нагрузочный тест** на создание сделок с leadId (в т.ч. сценарий G — 10 параллельных запросов с одним leadId).
3. **Только если всё чисто** — начинать ЭТАП 2 (нормализация stage_history).
4. **После миграции ЭТАПА 2** — снова прогнать e2e и выполнить **чек-лист закрытия ЭТАПА 2** (см. STAGE_2_PLAN.md, §6): e2e, проверка INSERT в stage_history, EXPLAIN по индексу, проверка analytics. Только после зелёного сигнала — считать ЭТАП 2 закрытым.
5. После ЭТАПА 2 — ЭТАП 4 (автосоздание сделки; архитектура — см. STAGE_4_ARCHITECTURE.md).

После прохождения сценариев A–G и нагрузочного теста ЭТАП 3 можно считать стабилизированным. Официально закрывать ЭТАП 2 — только после выполнения чек-листа из STAGE_2_PLAN §6.
