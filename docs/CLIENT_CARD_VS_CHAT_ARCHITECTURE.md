# Карточка клиента vs чат: архитектура мультипользовательской CRM

Документ отвечает на вопросы проектирования CRM, где **карточка клиента** — основная сущность воронки, а **чаты** — связанные сущности (личные от разных пользователей, групповые).

---

## 1. Вывод по концепции

### 1.1 Корректность модели

**Да, модель корректна.** Карточка клиента (contact) как основная сущность воронки при множестве чатов — правильный выбор по следующим причинам:

- **Один клиент — много точек касания.** Один и тот же человек может писать в личку разным сотрудникам и участвовать в групповых чатах. Воронка должна отражать статус **клиента**, а не каждого диалога по отдельности.
- **Единая история и контекст.** Все переписки (личные + группы) должны собираться в одной карточке для сквозной аналитики, скриптов и автоматизаций.
- **Нет дублирования в воронке.** При движении «чатов по воронке» один человек мог бы давать несколько карточек (по числу чатов); при движении «клиентов» — одна карточка, несколько чатов.
- **Командная работа.** Несколько пользователей CRM могут работать с одним клиентом; назначение, этап, теги — на уровне клиента, а не чата.

Итого: **воронка двигает клиентов (карточки); чаты — каналы коммуникации, привязанные к карточке.**

---

## 2. Плюсы и минусы подхода

### 2.1 Карточка клиента как основная сущность (рекомендуемый подход)

| Плюсы | Минусы |
|-------|--------|
| Один клиент = одна запись в воронке, нет дублей | Сложнее дедупликация при синхронизации (нужны правила по telegram_id / phone / email) |
| Вся переписка (лички + группы) в одном месте | Групповые чаты: один «чат» связан с многими клиентами (участники) |
| Единый контекст для AI, скриптов, автоответов | Нужна явная модель «чат ↔ клиент(ы)» |
| Командная работа: этап/владелец на уровне клиента | При смене телефона/аккаунта клиента — нужна политика слияния/обновления |
| Аналитика по клиентам, а не по чатам | |

### 2.2 Движение чатов по воронке (альтернатива)

| Плюсы | Минусы |
|-------|--------|
| Проще модель: один чат = одна сущность | Один человек = несколько карточек (по числу чатов/аккаунтов) |
| Не нужна дедупликация контактов | Дубли в воронке, путаница у менеджеров |
| | Нет единой истории по клиенту |
| | Сложнее сквозная аналитика и автоматизация |

**Вывод:** для мультипользовательского workspace с несколькими аккаунтами и групповыми чатами предпочтительна модель «клиент — главная сущность, чаты — связанные».

---

## 3. Рекомендуемая архитектура

### 3.1 Доменная модель (entities / relations)

- **Organization (Workspace)**  
  Владеет пользователями, аккаунтами мессенджеров, контактами, сделками, воронками.

- **Contact (карточка клиента)**  
  - Одна запись на «реального» клиента в рамках organization.  
  - Идентификация: `telegram_id` (основной для Telegram), опционально `phone`, `email`.  
  - Атрибуты: имя, фамилия, отображаемое имя (`display_name`), Telegram @username, компания, этап воронки (или через Deal), теги, владелец и т.д.  
  - **При отключении или удалении BD-аккаунта контакты не удаляются** — они принадлежат организации; сообщения и чаты могут быть привязаны к отключённому аккаунту, но карточки клиентов остаются в CRM.

- **Chat (конкретный диалог в мессенджере)**  
  - Один чат = один аккаунт + один канал (channel) + один channel_id (peer id).  
  - Имеет тип: личный (user), группа (chat), канал (channel).  
  - Связь с клиентами:  
    - **Личный чат:** один чат ↔ один contact (двусторонняя связь).  
    - **Групповой/канал:** один чат ↔ много contacts (участники/авторы сообщений).

- **Message**  
  - Принадлежит одному Chat и одному Contact (автор/отправитель для исходящих, адресат для входящих в 1:1; в группах — автор).  
  - Уже есть: `contact_id`, `bd_account_id`, `channel`, `channel_id`.

- **Deal (сделка)**  
  - Привязывается к **контакту** (и опционально к чату для контекста).  
  - Движение по воронке — по сделке/клиенту, а не по чату.

Связи:

- `Contact 1 — * Chat` (один контакт — много чатов: личные с разными аккаунтами, участие в группах).  
- `Chat 1 — * Contact` только для групповых чатов (много участников).  
- `Message * — 1 Chat`, `Message * — 1 Contact`.

### 3.2 База данных: основные таблицы и связи

Текущее состояние (кратко):

- `contacts` — уже есть; `organization_id`, `telegram_id`, first_name, last_name, email, phone.
- `messages` — contact_id, bd_account_id, channel, channel_id (чат неявно = пара bd_account_id + channel_id).
- `bd_account_sync_chats` — какие чаты синкать по аккаунту (bd_account_id, telegram_chat_id, title, peer_type); связи с contact нет.

Чего не хватает для явной модели «чат ↔ клиент»:

1. **Явная сущность «чат» в рамках workspace** (опционально, но упрощает запросы и UI):
   - Таблица `chats` (в рамках organization):
     - `id` (uuid), `organization_id`, `bd_account_id`, `channel`, `channel_id` (unique вместе), `peer_type` (user/chat/channel), `title`, `created_at`, `updated_at`.
   - Уникальность: `(organization_id, bd_account_id, channel, channel_id)`.
   - Для личного чата: одна запись в `chats` + одна запись в связке «чат–контакт».

2. **Связь «чат — контакт(ы)»**:
   - Таблица `chat_contacts`:
     - `chat_id` (FK chats), `contact_id` (FK contacts), `role` (например 'participant' для групп, 'counterparty' для 1:1).
     - Уникальность: `(chat_id, contact_id)`.
   - Личный чат: одна строка (chat ↔ один contact).
   - Групповой чат: много строк (один chat, много contact_id — по мере появления сообщений от участников).

3. **Дедупликация контактов при синхронизации**:
   - Ключ поиска контакта в рамках organization:
     - В первую очередь `telegram_id` (для Telegram).
     - При отсутствии telegram_id — по `phone` (нормализованный) или `email`.
   - При создании контакта из нового чата:
     - Сначала `SELECT contact WHERE organization_id = ? AND (telegram_id = ? OR (telegram_id IS NULL AND phone = ?) OR (telegram_id IS NULL AND email = ?))`.
     - Если найден — использовать этот contact_id и привязать чат к нему (см. ниже).
     - Если не найден — `INSERT` contact, затем привязать чат.

4. **Создание/обновление чата и привязка к контакту** (логика при синхронизации):
   - Для каждого диалога из аккаунта: (bd_account_id, channel, channel_id) → получить или создать запись в `chats`.
   - Для **личного** чата (peer_type = user):  
     - По telegram_id (channel_id в 1:1 = telegram_id пользователя) найти или создать contact; затем `INSERT INTO chat_contacts (chat_id, contact_id, role) VALUES (..., 'counterparty') ON CONFLICT DO NOTHING`.
   - Для **группы/канала**:  
     - Чат уже есть; контакты добавляются по мере появления сообщений (автор сообщения → ensureContactForTelegramId(senderId) → добавить в chat_contacts если ещё нет).

Так можно сохранить текущую схему почти без изменений и добавить только:

- Таблицу `chats` (organization_id, bd_account_id, channel, channel_id, peer_type, title, …).
- Таблицу `chat_contacts` (chat_id, contact_id, role).
- В логике синхронизации (bd-accounts-service): после ensureContactForTelegramId — создание/обновление `chats` и `chat_contacts`.

Сообщения можно оставить как есть: `messages.contact_id` + `bd_account_id` + `channel_id` уже задают и чат, и контакт. Таблицы `chats` и `chat_contacts` дают явный граф «клиент ↔ чаты» для UI и отчётов.

### 3.3 Как избежать дубликатов клиентов при синхронизации

1. **Единый ключ в рамках organization**
   - Telegram: `telegram_id` — главный идентификатор. Один telegram_id в организации = один contact.
   - При первом появлении контакта (из любого аккаунта) создаётся одна карточка; при появлении того же telegram_id из другого аккаунта — поиск по `organization_id + telegram_id`, при нахождении — не создавать новый contact, а привязать новый чат к существующему.

2. **Порядок при синхронизации**
   - Для каждого диалога: определить peer_type (user/chat/channel).
   - Для user: по channel_id (telegram user id) выполнить «find or create contact» по (organization_id, telegram_id).
   - Создать или обновить запись в `chats` (по organization_id, bd_account_id, channel, channel_id).
   - Добавить связь chat_contacts(chat_id, contact_id).

3. **Разрешение конфликтов имён**
   - При объединении двух аккаунтов первый созданный контакт может иметь «Telegram 12345», второй привязка — уже с именем из профиля. Рекомендация: при привязке нового чата к существующему контакту обновлять first_name/last_name/display_name только если у существующего контакта они пустые или «дефолтные» (например, «Telegram …»).

4. **Несколько идентификаторов (phone, email, telegram_id)**
   - Хранить все в одной карточке. Поиск при дедупликации: сначала telegram_id, затем phone (нормализованный), затем email. При слиянии (ручном или автоматическом) — один контакт с заполненными полями из всех источников.

---

## 4. Edge cases

| Кейс | Описание | Рекомендация |
|------|----------|--------------|
| Групповые чаты | Один чат — много участников (много контактов). | Чат один; в `chat_contacts` много строк (chat_id, contact_id). Сообщения: contact_id = автор. В UI карточки клиента: список чатов = личные + группы, где он участник. |
| Смена контакта в чате | В личном чате пользователь сменил номер/аккаунт. | По текущей логике будет два контакта (два telegram_id). Решение: ручное слияние карточек в UI; опционально — эвристики по имени/номеру и подсказка «возможно тот же клиент». |
| Разные идентификаторы | Один человек: telegram_id, другой аккаунт — только phone. | Дедупликация по phone/email при создании контакта; при привязке чата по telegram — обновить contact.telegram_id если был пустой. |
| Личный чат vs группа | В группе сообщения от разных отправителей. | Каждое сообщение → contact_id = автор. Участники группы по мере появления в сообщениях добавляются в chat_contacts. |
| Архив / удалённые чаты | Чат удалён в мессенджере или выведен из синка. | Не удалять контакт. Чат можно помечать как inactive или удалять связь chat_contacts; история сообщений остаётся. |
| «Избранное» / Saved Messages | Чат с самим собой. | Исключать из создания контакта и из воронки (уже делается в коде: пропуск, если chatId === accountTelegramId). |

---

## 5. Возможные риски

1. **Производительность**  
   Большое число чатов и сообщений → тяжёлые выборки «все чаты контакта» и «все сообщения по контакту». Смягчение: индексы (organization_id, contact_id), (bd_account_id, channel_id); пагинация; кэш списка чатов на карточке.

2. **Ошибочное слияние**  
   Автоматическая дедупликация только по telegram_id безопасна; по phone/email возможны ложные слияния (разные люди, один телефон). Рекомендация: авто-слияние только по telegram_id; по phone/email — поиск дублей и ручное слияние в UI.

3. **Гонки при параллельной синхронизации**  
   Два аккаунта синкаются одновременно, один и тот же telegram_id — два потока создают контакт. Решение: unique constraint на (organization_id, telegram_id); в коде — «find or create» с повторной попыткой чтения после конфликта (как в текущем ensureContactForTelegramId).

4. **Миграция существующих данных**  
   Сейчас сообщения уже привязаны к contact_id; чат неявный. При введении `chats` и `chat_contacts` нужна миграция: по существующим (bd_account_id, channel_id) создать записи в `chats` и заполнить `chat_contacts` из уникальных (contact_id, bd_account_id, channel_id) из messages.

---

## 6. Рекомендации по дальнейшему развитию модели

1. **Краткосрочно (без смены воронки)**  
   - Оставить воронку и сделки на уровне контакта (и сделки привязаны к contact_id; опционально — к чату для контекста).  
   - В UI «Сообщения»: группировать чаты по контакту где возможно (личные чаты с одним и тем же telegram_id показывать как один «клиент» с несколькими диалогами).  
   - Использовать текущий `ensureContactForTelegramId` и гарантировать, что во всей организации один telegram_id = один contact.

2. **Введение явной модели чатов**  
   - Добавить миграции: `chats`, `chat_contacts`.  
   - В bd-accounts-service при синхронизации диалогов и при обработке входящих сообщений: создавать/обновлять `chats` и `chat_contacts`.  
   - API: например, `GET /api/contacts/:id/chats` — все чаты контакта (личные + группы, где он есть в chat_contacts).

3. **Карточка клиента в UI**  
   - Единый экран «Карточка клиента»: воронка (этап/сделка), все чаты (вкладки или список: личка с менеджером A, личка с менеджером B, группа X), таймлайн сообщений по всем чатам или по выбранному.

4. **Дедупликация и слияние**  
   - Инструмент «Найти дубликаты» (по telegram_id уже нет дублей; по phone/email — поиск и ручное слияние).  
   - При слиянии: один контакт-победитель, перенос сделок и привязка чатов к нему, объединение истории сообщений в одном представлении.

5. **Групповые чаты**  
   - Явно хранить участников в `chat_contacts` по мере появления сообщений; в карточке контакта показывать «участие в группах»; при создании сделки из группы — выбор контакта-участника и привязка к нему.

Эта схема согласована с текущей схемой БД (contacts, messages, bd_account_sync_chats, deals) и логикой ensureContactForTelegramId и позволяет эволюционно перейти к модели «карточка клиента — основная сущность, чаты — связанные».
